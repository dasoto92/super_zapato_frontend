'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

module.exports = sourcePlugin;

function sourcePlugin(babel) {
  var t = babel.types;


  return {
    name: 'source',
    visitor: {
      Expression(path) {
        var node = path.node;

        var _getSourceNameComment = getSourceNameCommentsFromNode(node),
            leading = _getSourceNameComment.leading,
            trailing = _getSourceNameComment.trailing;

        if (node.__sourceHandled || !leading.length && !trailing.length) {
          return;
        }

        node.__sourceHandled = true;
        var lastLeading = leading[leading.length - 1];
        var firstTrailing = trailing[trailing.length - 1];
        var sourceName = lastLeading.name;

        var sourceCode = makeSourceCode(this.file.code, lastLeading.node, firstTrailing.node);

        var variablePath = path.find(function (path) {
          return path.scope.bindings[sourceName];
        });
        if (!variablePath || !variablePath.scope) {
          throw path.buildCodeFrameError(`Couldn't find the 'let/var ${sourceName}' variable for @source ${sourceName}!`);
        }
        variablePath.scope.bindings[sourceName].path.node.init = t.stringLiteral(sourceCode);
        removeSourceCommentsFromNode(node);
      },
      Scopable(path) {
        var _this = this;

        // Don't handle nodes twice
        if (path.node.__sourceHandled) {
          return;
        }
        path.node.__sourceHandled = true;

        var body = path.node.body;


        var sources = {};

        var handleComment = function (comment) {
          if (sources[comment.name]) {
            // Don't handle duplicates
            if (sources[comment.name].start === comment.node) {
              return;
            }
            // Don't handle closed sources
            if (sources[comment.name].end) {
              return;
            }
            // Close source
            sources[comment.name].end = comment.node;
          } else {
            // Otherwise, open it up
            sources[comment.name] = {
              start: comment.node
            };
          }
        };

        if (body.length) {
          body.forEach(function (node) {
            var _getSourceNameComment2 = getSourceNameCommentsFromNode(node),
                leading = _getSourceNameComment2.leading,
                trailing = _getSourceNameComment2.trailing;

            [].concat(_toConsumableArray(leading), _toConsumableArray(trailing)).forEach(handleComment);
          });
        }

        Object.keys(sources).forEach(function (sourceName) {
          var source = sources[sourceName];
          var sourceCode = makeSourceCode(_this.file.code, source.start, source.end);
          var variablePath = path.find(function (path) {
            return path.scope.bindings[sourceName];
          });
          if (!variablePath || !variablePath.scope) {
            throw path.buildCodeFrameError(`Couldn't find the 'let/var ${sourceName}' variable for @source ${sourceName}!`);
          }
          variablePath.scope.bindings[sourceName].path.node.init = t.stringLiteral(sourceCode);
          removeSourceCommentsFromNode(source.start);
          removeSourceCommentsFromNode(source.end);
        });
      }
    }
  };
}

function isSourceComment(comment) {
  var normalizedComment = comment.value.trim().split(' ');
  if (normalizedComment.length !== 2) {
    return;
  }
  var isSource = normalizedComment[0].trim() === '@source';
  var hasName = normalizedComment[1];
  hasName = hasName && normalizedComment[1].trim();

  return isSource && hasName ? { name: hasName, node: comment } : false;
}

function getSourceNameCommentsFromNode(node) {
  var leadingComments = node.leadingComments,
      trailingComments = node.trailingComments;

  return {
    leading: (leadingComments || []).map(isSourceComment).filter(Boolean),
    trailing: (trailingComments || []).map(isSourceComment).filter(Boolean)
  };
}

function removeSourceCommentsFromNode(node) {
  node.leadingComments = node.leadingComments ? node.leadingComments.filter(function (d) {
    return !isSourceComment(d);
  }) : node.leadingComments;
  node.trailingComments = node.trailingComments ? node.trailingComments.filter(function (d) {
    return !isSourceComment(d);
  }) : node.trailingComments;
  return node;
}

function makeSourceCode(source, startComment, endComment) {
  var startLine = startComment.loc.end.line;
  var endLine = endComment.loc.start.line;
  var startColumn = startComment.loc.end.column;
  var endColumn = endComment.loc.start.column;
  var isSingleLine = startLine === endLine;

  var sourceLines = source.split('\n').slice(startLine - 1, isSingleLine ? startLine : endLine);

  sourceLines[0] = sourceLines[0].slice(startColumn);
  sourceLines[sourceLines.length - 1] = sourceLines[sourceLines.length - 1].slice(0, isSingleLine ? endColumn - startColumn : endColumn);
  sourceLines = sourceLines.filter(function (d) {
    return d.length;
  });
  var shortestIndentation = sourceLines.reduce(function (acc, next) {
    var length = 0;
    while (next.charAt(length) === ' ') {
      length += 1;
    }
    return acc < length ? acc : length;
  }, Infinity);
  sourceLines = sourceLines.filter(function (d) {
    return d.replace(/[ ]*/, '');
  });
  return sourceLines.map(function (d) {
    return d.substring(shortestIndentation);
  }).join('\n');
}